/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { type AdditionalDataHolder, type ApiError, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Download}
 */
export function createDownloadFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDownload;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DownloadPaginatedData}
 */
export function createDownloadPaginatedDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDownloadPaginatedData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DownloadStats}
 */
export function createDownloadStatsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDownloadStats;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Movie}
 */
export function createMovieFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMovie;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MovieSummary}
 */
export function createMovieSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMovieSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MovieSummaryPaginatedData}
 */
export function createMovieSummaryPaginatedDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMovieSummaryPaginatedData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProblemDetails}
 */
export function createProblemDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProblemDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Scrape}
 */
export function createScrapeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoScrape;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ScrapePaginatedData}
 */
export function createScrapePaginatedDataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoScrapePaginatedData;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Torrent}
 */
export function createTorrentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTorrent;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDownload(download: Partial<Download> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "complete": n => { download.complete = n.getBooleanValue(); },
        "id": n => { download.id = n.getStringValue(); },
        "movieId": n => { download.movieId = n.getStringValue(); },
        "name": n => { download.name = n.getStringValue(); },
        "startDate": n => { download.startDate = n.getDateValue(); },
        "stats": n => { download.stats = n.getObjectValue<DownloadStats>(createDownloadStatsFromDiscriminatorValue); },
        "transmissionId": n => { download.transmissionId = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDownloadPaginatedData(downloadPaginatedData: Partial<DownloadPaginatedData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "count": n => { downloadPaginatedData.count = n.getNumberValue(); },
        "data": n => { downloadPaginatedData.data = n.getCollectionOfObjectValues<Download>(createDownloadFromDiscriminatorValue); },
        "limit": n => { downloadPaginatedData.limit = n.getNumberValue(); },
        "page": n => { downloadPaginatedData.page = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDownloadStats(downloadStats: Partial<DownloadStats> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "eta": n => { downloadStats.eta = n.getStringValue(); },
        "files": n => { downloadStats.files = n.getCollectionOfPrimitiveValues<string>(); },
        "isStalled": n => { downloadStats.isStalled = n.getBooleanValue(); },
        "name": n => { downloadStats.name = n.getStringValue(); },
        "percentDone": n => { downloadStats.percentDone = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMovie(movie: Partial<Movie> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dateCreated": n => { movie.dateCreated = n.getDateValue(); },
        "description": n => { movie.description = n.getStringValue(); },
        "genres": n => { movie.genres = n.getCollectionOfPrimitiveValues<string>(); },
        "id": n => { movie.id = n.getStringValue(); },
        "imdbCode": n => { movie.imdbCode = n.getStringValue(); },
        "inLibrary": n => { movie.inLibrary = n.getBooleanValue(); },
        "language": n => { movie.language = n.getStringValue(); },
        "rating": n => { movie.rating = n.getNumberValue(); },
        "runtime": n => { movie.runtime = n.getStringValue(); },
        "searchableTitle": n => { movie.searchableTitle = n.getStringValue(); },
        "title": n => { movie.title = n.getStringValue(); },
        "torrents": n => { movie.torrents = n.getCollectionOfObjectValues<Torrent>(createTorrentFromDiscriminatorValue); },
        "year": n => { movie.year = n.getNumberValue(); },
        "youTubeTrailerCode": n => { movie.youTubeTrailerCode = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMovieSummary(movieSummary: Partial<MovieSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dateCreated": n => { movieSummary.dateCreated = n.getDateValue(); },
        "description": n => { movieSummary.description = n.getStringValue(); },
        "genres": n => { movieSummary.genres = n.getCollectionOfPrimitiveValues<string>(); },
        "id": n => { movieSummary.id = n.getStringValue(); },
        "imdbCode": n => { movieSummary.imdbCode = n.getStringValue(); },
        "inLibrary": n => { movieSummary.inLibrary = n.getBooleanValue(); },
        "quality": n => { movieSummary.quality = n.getCollectionOfPrimitiveValues<string>(); },
        "rating": n => { movieSummary.rating = n.getNumberValue(); },
        "runtime": n => { movieSummary.runtime = n.getStringValue(); },
        "title": n => { movieSummary.title = n.getStringValue(); },
        "year": n => { movieSummary.year = n.getNumberValue(); },
        "youTubeTrailerCode": n => { movieSummary.youTubeTrailerCode = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMovieSummaryPaginatedData(movieSummaryPaginatedData: Partial<MovieSummaryPaginatedData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "count": n => { movieSummaryPaginatedData.count = n.getNumberValue(); },
        "data": n => { movieSummaryPaginatedData.data = n.getCollectionOfObjectValues<MovieSummary>(createMovieSummaryFromDiscriminatorValue); },
        "limit": n => { movieSummaryPaginatedData.limit = n.getNumberValue(); },
        "page": n => { movieSummaryPaginatedData.page = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProblemDetails(problemDetails: Partial<ProblemDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "detail": n => { problemDetails.detail = n.getStringValue(); },
        "instance": n => { problemDetails.instance = n.getStringValue(); },
        "status": n => { problemDetails.status = n.getNumberValue(); },
        "title": n => { problemDetails.title = n.getStringValue(); },
        "type": n => { problemDetails.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoScrape(scrape: Partial<Scrape> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "endDate": n => { scrape.endDate = n.getDateValue(); },
        "error": n => { scrape.errorEscaped = n.getStringValue(); },
        "id": n => { scrape.id = n.getStringValue(); },
        "movieCount": n => { scrape.movieCount = n.getNumberValue(); },
        "startDate": n => { scrape.startDate = n.getDateValue(); },
        "success": n => { scrape.success = n.getBooleanValue(); },
        "torrentCount": n => { scrape.torrentCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoScrapePaginatedData(scrapePaginatedData: Partial<ScrapePaginatedData> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "count": n => { scrapePaginatedData.count = n.getNumberValue(); },
        "data": n => { scrapePaginatedData.data = n.getCollectionOfObjectValues<Scrape>(createScrapeFromDiscriminatorValue); },
        "limit": n => { scrapePaginatedData.limit = n.getNumberValue(); },
        "page": n => { scrapePaginatedData.page = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTorrent(torrent: Partial<Torrent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dateCreated": n => { torrent.dateCreated = n.getDateValue(); },
        "hash": n => { torrent.hash = n.getStringValue(); },
        "quality": n => { torrent.quality = n.getStringValue(); },
        "sizeBytes": n => { torrent.sizeBytes = n.getNumberValue(); },
        "type": n => { torrent.type = n.getStringValue(); },
    }
}
export interface Download extends Parsable {
    /**
     * The complete property
     */
    complete?: boolean;
    /**
     * The id property
     */
    id?: string;
    /**
     * The movieId property
     */
    movieId?: string;
    /**
     * The name property
     */
    name?: string;
    /**
     * The startDate property
     */
    startDate?: Date;
    /**
     * The stats property
     */
    stats?: DownloadStats;
    /**
     * The transmissionId property
     */
    transmissionId?: number;
}
export type DownloadField = (typeof DownloadFieldObject)[keyof typeof DownloadFieldObject];
export interface DownloadPaginatedData extends Parsable {
    /**
     * The count property
     */
    count?: number;
    /**
     * The data property
     */
    data?: Download[];
    /**
     * The limit property
     */
    limit?: number;
    /**
     * The page property
     */
    page?: number;
}
export interface DownloadStats extends Parsable {
    /**
     * The eta property
     */
    eta?: string;
    /**
     * The files property
     */
    files?: string[];
    /**
     * The isStalled property
     */
    isStalled?: boolean;
    /**
     * The name property
     */
    name?: string;
    /**
     * The percentDone property
     */
    percentDone?: number;
}
export interface Movie extends Parsable {
    /**
     * The dateCreated property
     */
    dateCreated?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The genres property
     */
    genres?: string[];
    /**
     * The id property
     */
    id?: string;
    /**
     * The imdbCode property
     */
    imdbCode?: string;
    /**
     * The inLibrary property
     */
    inLibrary?: boolean;
    /**
     * The language property
     */
    language?: string;
    /**
     * The rating property
     */
    rating?: number;
    /**
     * The runtime property
     */
    runtime?: string;
    /**
     * The searchableTitle property
     */
    searchableTitle?: string;
    /**
     * The title property
     */
    title?: string;
    /**
     * The torrents property
     */
    torrents?: Torrent[];
    /**
     * The year property
     */
    year?: number;
    /**
     * The youTubeTrailerCode property
     */
    youTubeTrailerCode?: string;
}
export interface MovieSummary extends Parsable {
    /**
     * The dateCreated property
     */
    dateCreated?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The genres property
     */
    genres?: string[];
    /**
     * The id property
     */
    id?: string;
    /**
     * The imdbCode property
     */
    imdbCode?: string;
    /**
     * The inLibrary property
     */
    inLibrary?: boolean;
    /**
     * The quality property
     */
    quality?: string[];
    /**
     * The rating property
     */
    rating?: number;
    /**
     * The runtime property
     */
    runtime?: string;
    /**
     * The title property
     */
    title?: string;
    /**
     * The year property
     */
    year?: number;
    /**
     * The youTubeTrailerCode property
     */
    youTubeTrailerCode?: string;
}
export interface MovieSummaryPaginatedData extends Parsable {
    /**
     * The count property
     */
    count?: number;
    /**
     * The data property
     */
    data?: MovieSummary[];
    /**
     * The limit property
     */
    limit?: number;
    /**
     * The page property
     */
    page?: number;
}
export interface ProblemDetails extends AdditionalDataHolder, ApiError, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The detail property
     */
    detail?: string;
    /**
     * The instance property
     */
    instance?: string;
    /**
     * The status property
     */
    status?: number;
    /**
     * The title property
     */
    title?: string;
    /**
     * The type property
     */
    type?: string;
}
export interface Scrape extends Parsable {
    /**
     * The endDate property
     */
    endDate?: Date;
    /**
     * The error property
     */
    errorEscaped?: string;
    /**
     * The id property
     */
    id?: string;
    /**
     * The movieCount property
     */
    movieCount?: number;
    /**
     * The startDate property
     */
    startDate?: Date;
    /**
     * The success property
     */
    success?: boolean;
    /**
     * The torrentCount property
     */
    torrentCount?: number;
}
export type ScrapeField = (typeof ScrapeFieldObject)[keyof typeof ScrapeFieldObject];
export interface ScrapePaginatedData extends Parsable {
    /**
     * The count property
     */
    count?: number;
    /**
     * The data property
     */
    data?: Scrape[];
    /**
     * The limit property
     */
    limit?: number;
    /**
     * The page property
     */
    page?: number;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDownload(writer: SerializationWriter, download: Partial<Download> | undefined = {}) : void {
    writer.writeBooleanValue("complete", download.complete);
    writer.writeStringValue("id", download.id);
    writer.writeStringValue("movieId", download.movieId);
    writer.writeStringValue("name", download.name);
    writer.writeDateValue("startDate", download.startDate);
    writer.writeObjectValue<DownloadStats>("stats", download.stats, serializeDownloadStats);
    writer.writeNumberValue("transmissionId", download.transmissionId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDownloadPaginatedData(writer: SerializationWriter, downloadPaginatedData: Partial<DownloadPaginatedData> | undefined = {}) : void {
    writer.writeNumberValue("count", downloadPaginatedData.count);
    writer.writeCollectionOfObjectValues<Download>("data", downloadPaginatedData.data, serializeDownload);
    writer.writeNumberValue("limit", downloadPaginatedData.limit);
    writer.writeNumberValue("page", downloadPaginatedData.page);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDownloadStats(writer: SerializationWriter, downloadStats: Partial<DownloadStats> | undefined = {}) : void {
    writer.writeStringValue("eta", downloadStats.eta);
    writer.writeCollectionOfPrimitiveValues<string>("files", downloadStats.files);
    writer.writeBooleanValue("isStalled", downloadStats.isStalled);
    writer.writeStringValue("name", downloadStats.name);
    writer.writeNumberValue("percentDone", downloadStats.percentDone);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMovie(writer: SerializationWriter, movie: Partial<Movie> | undefined = {}) : void {
    writer.writeDateValue("dateCreated", movie.dateCreated);
    writer.writeStringValue("description", movie.description);
    writer.writeCollectionOfPrimitiveValues<string>("genres", movie.genres);
    writer.writeStringValue("id", movie.id);
    writer.writeStringValue("imdbCode", movie.imdbCode);
    writer.writeBooleanValue("inLibrary", movie.inLibrary);
    writer.writeStringValue("language", movie.language);
    writer.writeNumberValue("rating", movie.rating);
    writer.writeStringValue("runtime", movie.runtime);
    writer.writeStringValue("searchableTitle", movie.searchableTitle);
    writer.writeStringValue("title", movie.title);
    writer.writeCollectionOfObjectValues<Torrent>("torrents", movie.torrents, serializeTorrent);
    writer.writeNumberValue("year", movie.year);
    writer.writeStringValue("youTubeTrailerCode", movie.youTubeTrailerCode);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMovieSummary(writer: SerializationWriter, movieSummary: Partial<MovieSummary> | undefined = {}) : void {
    writer.writeDateValue("dateCreated", movieSummary.dateCreated);
    writer.writeStringValue("description", movieSummary.description);
    writer.writeCollectionOfPrimitiveValues<string>("genres", movieSummary.genres);
    writer.writeStringValue("id", movieSummary.id);
    writer.writeStringValue("imdbCode", movieSummary.imdbCode);
    writer.writeBooleanValue("inLibrary", movieSummary.inLibrary);
    writer.writeCollectionOfPrimitiveValues<string>("quality", movieSummary.quality);
    writer.writeNumberValue("rating", movieSummary.rating);
    writer.writeStringValue("runtime", movieSummary.runtime);
    writer.writeStringValue("title", movieSummary.title);
    writer.writeNumberValue("year", movieSummary.year);
    writer.writeStringValue("youTubeTrailerCode", movieSummary.youTubeTrailerCode);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMovieSummaryPaginatedData(writer: SerializationWriter, movieSummaryPaginatedData: Partial<MovieSummaryPaginatedData> | undefined = {}) : void {
    writer.writeNumberValue("count", movieSummaryPaginatedData.count);
    writer.writeCollectionOfObjectValues<MovieSummary>("data", movieSummaryPaginatedData.data, serializeMovieSummary);
    writer.writeNumberValue("limit", movieSummaryPaginatedData.limit);
    writer.writeNumberValue("page", movieSummaryPaginatedData.page);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProblemDetails(writer: SerializationWriter, problemDetails: Partial<ProblemDetails> | undefined = {}) : void {
    writer.writeStringValue("detail", problemDetails.detail);
    writer.writeStringValue("instance", problemDetails.instance);
    writer.writeNumberValue("status", problemDetails.status);
    writer.writeStringValue("title", problemDetails.title);
    writer.writeStringValue("type", problemDetails.type);
    writer.writeAdditionalData(problemDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeScrape(writer: SerializationWriter, scrape: Partial<Scrape> | undefined = {}) : void {
    writer.writeDateValue("endDate", scrape.endDate);
    writer.writeStringValue("error", scrape.errorEscaped);
    writer.writeStringValue("id", scrape.id);
    writer.writeNumberValue("movieCount", scrape.movieCount);
    writer.writeDateValue("startDate", scrape.startDate);
    writer.writeBooleanValue("success", scrape.success);
    writer.writeNumberValue("torrentCount", scrape.torrentCount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeScrapePaginatedData(writer: SerializationWriter, scrapePaginatedData: Partial<ScrapePaginatedData> | undefined = {}) : void {
    writer.writeNumberValue("count", scrapePaginatedData.count);
    writer.writeCollectionOfObjectValues<Scrape>("data", scrapePaginatedData.data, serializeScrape);
    writer.writeNumberValue("limit", scrapePaginatedData.limit);
    writer.writeNumberValue("page", scrapePaginatedData.page);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTorrent(writer: SerializationWriter, torrent: Partial<Torrent> | undefined = {}) : void {
    writer.writeDateValue("dateCreated", torrent.dateCreated);
    writer.writeStringValue("hash", torrent.hash);
    writer.writeStringValue("quality", torrent.quality);
    writer.writeNumberValue("sizeBytes", torrent.sizeBytes);
    writer.writeStringValue("type", torrent.type);
}
export type SourceMovieField = (typeof SourceMovieFieldObject)[keyof typeof SourceMovieFieldObject];
export interface Torrent extends Parsable {
    /**
     * The dateCreated property
     */
    dateCreated?: Date;
    /**
     * The hash property
     */
    hash?: string;
    /**
     * The quality property
     */
    quality?: string;
    /**
     * The sizeBytes property
     */
    sizeBytes?: number;
    /**
     * The type property
     */
    type?: string;
}
export const DownloadFieldObject = {
    DateStarted: "DateStarted",
} as const;
export const ScrapeFieldObject = {
    StartDate: "StartDate",
} as const;
export const SourceMovieFieldObject = {
    Title: "Title",
    DateCreated: "DateCreated",
    Year: "Year",
} as const;
/* tslint:enable */
/* eslint-enable */
